---
title: "copulas_en_R"
format: html
---


## Principal = Librerias y data frame

```{r}
library(dplyr)
library(tidyr)
library(readxl)
library(stringr)
library(copula)
library(VineCopula)
library(actuar)

df <- read.csv('../data/clean/datos_limpios_log.csv')

clasificar_evento <- function(texto) {
  texto <- tolower(texto)

  dplyr::case_when(
    str_detect(texto, "huracán|hurricane|otto|eta|julia") ~ "Huracan",
    str_detect(texto, "tormenta tropical|bonnie") ~ "Tormenta_Tropical",
    str_detect(texto, "temporal|lluvia|baja presión|onda tropical|zci|vertiente") ~ "Temporal_Lluvias",
    str_detect(texto, "frente frío|frente frio|frente") ~ "Frente_Frío",
    str_detect(texto, "sequía|deficit hídrico|sequ\\?a") ~ "Sequía",
    str_detect(texto, "sismo|terremoto|deslizamiento") ~ "Sismo_Deslizamiento",
    str_detect(texto, "covid|epidemia|dengue|virus|enfermedad") ~ "Epidemia",
    TRUE ~ "Otros"
  )
}

df_eventos <- df %>%
  mutate(
    evento_tipo = clasificar_evento(evento),
    evento_id   = dplyr::group_indices(., ano, evento)
  )

df_evento_provincias <- df_eventos %>%
  group_by(evento_id, provincia) %>%
  summarise(total = sum(total), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = provincia, values_from = total)

df_evento_sectores <- df_eventos %>%
  group_by(evento_id, sector) %>%
  summarise(total = sum(total), .groups = "drop") %>%
  tidyr::pivot_wider(names_from = sector, values_from = total)

```

### Dataframes conjuntos

```{r}
construir_par_prov_sector <- function(df_prov, df_sec,
                                      provincia, sector,
                                      min_n = 20,
                                      quitar_todo_cero = TRUE) {

  df_pair <- df_prov %>%
    select(evento_id, !!provincia := all_of(provincia)) %>%
    inner_join(
      df_sec %>%
        select(evento_id, !!sector := all_of(sector)),
      by = "evento_id"
    )

  df_pair[[provincia]][is.na(df_pair[[provincia]])] <- 0
  df_pair[[sector]][is.na(df_pair[[sector]])] <- 0

  if (quitar_todo_cero) {
    df_pair <- df_pair %>%
      filter((.data[[provincia]] != 0) | (.data[[sector]] != 0))
  }

  if (nrow(df_pair) < min_n) {
    message("[Info] Menos de ", min_n,
            " observaciones para ", provincia, " - ", sector,
            ". Se omite este par.")
    return(NULL)
  }

  df_out <- df_pair %>%
    transmute(
      evento_id,
      X = .data[[provincia]],
      Y = .data[[sector]]
    )

  df_out
}


construir_par <- function(df_A, df_B, varA, varB, min_n = 20, quitar_todo_cero = TRUE) {

  varA <- as.character(varA)
  varB <- as.character(varB)


  df_pair <- df_A %>%
    select(evento_id, !!varA := all_of(varA)) %>%
    inner_join(
      df_B %>% select(evento_id, !!varB := all_of(varB)),
      by = "evento_id"
    )

  df_pair[[varA]][is.na(df_pair[[varA]])] <- 0
  df_pair[[varB]][is.na(df_pair[[varB]])] <- 0

  if (quitar_todo_cero) {
    df_pair <- df_pair %>%
      filter((.data[[varA]] != 0) | (.data[[varB]] != 0))
  }

  if (nrow(df_pair) < min_n) {
    message("[Info] Observaciones insuficientes para ", varA, " - ", varB)
    return(NULL)
  }

  df_out <- df_pair %>% transmute(
    evento_id,
    X = .data[[varA]],
    Y = .data[[varB]]
  )

  return(df_out)
}

```

## Cargar marginales

```{r}

pburr <- function(q, shape1, shape2, scale) {
  1 - (1 + (q/scale)^shape1)^(-shape2)
}

qburr <- function(p, shape1, shape2, scale) {
  scale * (((1 - p)^(-1/shape2) - 1))^(1/shape1)
  scale * (( (1 - p)^(-1/shape2) - 1 ))^(1/shape1)
}

pgpd <- function(x, xi, beta, u0) {
  if (abs(xi) < 1e-8) {
    return(1 - exp(-(x - u0) / beta))
  }
  1 - (1 + xi * (x - u0) / beta)^(-1/xi)
}

qgpd <- function(p, xi, beta, u0) {
  if (abs(xi) < 1e-8) {
    return(u0 - beta * log(1 - p))
  }
  u0 + beta * ((1 - p)^(-xi) - 1) / xi
}


ppareto <- function(x, shape, scale) {
  1 - (scale / x)^shape
}

qpareto <- function(p, shape, scale) {
  scale / (1 - p)^(1/shape)
}

```


```{r}
leer_marginal <- function(path_dir) {

  archivos <- list.files(path_dir, full.names = TRUE)
  tail_files <- archivos[grepl("tail", archivos, ignore.case = TRUE)]

  if (length(tail_files) == 0) {
    stop("No se encontraron COLAS (tail) en ", path_dir)
  }

  # Seleccionar archivo más reciente
  archivos <- list.files(path_dir, full.names = TRUE)

  body_files <- archivos[grepl("body", archivos, ignore.case = TRUE)]
  tail_files <- archivos[grepl("tail", archivos, ignore.case = TRUE)]

  if (length(tail_files) == 0) {
    stop("No se encontraron COLAS (tail) en ", path_dir)
  }

  # Seleccionar archivo más reciente
  seleccionar_ultimo <- function(files) {
    info <- file.info(files)
    files[which.max(info$mtime)]
  }

  tail_file <- seleccionar_ultimo(tail_files)
  message("[Marginal] Seleccionado TAIL: ", basename(tail_file))

  df_tail <- read.csv(tail_file)

  # ------------------------------------------------------------
  # Detectar modelo
  # ------------------------------------------------------------
  model <- tolower(df_tail$model_name[1])

  # ------------------------------------------------------------
  # Detectar columnas de parámetros automáticamente
  # ------------------------------------------------------------
  # Busca columnas como GPD_param1, Burr_param1, LN_param1, etc.
  param_cols <- grep("_param[0-9]+$", colnames(df_tail), value = TRUE)

  if (length(param_cols) == 0) {
    stop("No se detectaron columnas de parámetros en: ", tail_file)
  }

  # ------------------------------------------------------------
  # Convertir a numeric toda la cadena
  # ------------------------------------------------------------
  vals <- df_tail[param_cols]

  # Convertir strings y factores a numeric
  vals <- sapply(vals, function(v) {
    v <- as.character(v)
    v[v %in% c("", " ", "NA", "NaN", "nan", "NULL")] <- NA
    suppressWarnings(as.numeric(v))
  })

  vals <- as.data.frame(vals)

  # ------------------------------------------------------------
  # Promedio de toda la cadena (para cada parámetro)
  # ------------------------------------------------------------
  param_means <- colMeans(vals, na.rm = TRUE)

  if (any(is.na(param_means))) {
    stop("[ERROR] No se pudieron promediar parámetros en: ", basename(tail_file),
         "\nValores detectados:", paste(param_cols, collapse = ","))
  }

  # ------------------------------------------------------------
  # Construir salida
  # ------------------------------------------------------------
  out <- list(
    model_type = "tail",
    model_name = model,
    params = param_means
  )

  # incluir u_opt y p_u si existen
  opt_fields <- c("u_opt", "p_u", "threshold")
  for (f in opt_fields) {
    if (f %in% colnames(df_tail)) {
      out[[f]] <- df_tail[[f]][1]  # el threshold NO se promedia
    }
  }

  return(out)
}

transformar_a_U <- function(x, marginal) {

  tipo   <- marginal$model_type
  nombre <- tolower(marginal$model_name)
  params <- marginal$params

  # =====================
  # TAIL PARAMÉTRICA
  # =====================
  if (tipo == "tail") {

    # -------- BURR --------
    if (nombre == "burr") {
      Fx <- pburr(
        q = x,
        shape1 = params[1],
        shape2 = params[2],
        scale  = params[3]
      )
    }

    # -------- GPD --------
    else if (nombre == "gpd") {
      Fx <- pgpd(
        x    = x,
        xi   = params[1],
        beta = params[2],
        u0   = marginal$u_opt
      )
    }

    # -------- PARETO --------
    else if (nombre == "pareto") {
      Fx <- ppareto(
        x     = x,
        shape = params[1],
        scale = params[2]
      )
    }

    # -------- LOGNORMAL _TAIL --------
    else if (nombre == "ln_tail" || nombre == "lognormal") {
      Fx <- plnorm(
        x,
        meanlog = params[1],
        sdlog   = params[2]
      )
    }

    else {
      stop("Distribución tail no implementada: ", nombre)
    }
  }


  # =====================
  # BODY / KDE  (SI QUISIERAS USARLO)
  # =====================
  else if (tipo == "body") {

    xgrid <- marginal$x
    fgrid <- marginal$dens
    Fx <- approx(
      x = xgrid,
      y = cumsum(fgrid) / sum(fgrid),

  # PRIORIDAD 1 → TAIL (riesgo extremo)
  if (length(tail_files) >= 1) {
    tail_file <- seleccionar_ultimo(tail_files)
    message("[Marginal] Seleccionado TAIL: ", basename(tail_file))

    df_tail <- read.csv(tail_file)

    return(list(
      model_type = "tail",
      model_name = unique(df_tail$model_name)[1],
      param1 = df_tail$Burr_param1[1],
      param2 = df_tail$Burr_param2[1],
      param3 = df_tail$Burr_param3[1],
      p_u    = df_tail$p_u[1],
      u_opt  = df_tail$u_opt[1]
    ))
  }

  # ------------------------------------------------------------
  # Convertir a numeric toda la cadena
  # ------------------------------------------------------------
  vals <- df_tail[param_cols]

  # Convertir strings y factores a numeric
  vals <- sapply(vals, function(v) {
    v <- as.character(v)
    v[v %in% c("", " ", "NA", "NaN", "nan", "NULL")] <- NA
    suppressWarnings(as.numeric(v))
  })

  vals <- as.data.frame(vals)

  # ------------------------------------------------------------
  # Promedio de toda la cadena (para cada parámetro)
  # ------------------------------------------------------------
  param_means <- colMeans(vals, na.rm = TRUE)

  if (any(is.na(param_means))) {
    stop("[ERROR] No se pudieron promediar parámetros en: ", basename(tail_file),
         "\nValores detectados:", paste(param_cols, collapse = ","))
  }

  # ------------------------------------------------------------
  # Construir salida
  # ------------------------------------------------------------
  out <- list(
    model_type = "tail",
    model_name = model,
    params = param_means
  )

  # incluir u_opt y p_u si existen
  opt_fields <- c("u_opt", "p_u", "threshold")
  for (f in opt_fields) {
    if (f %in% colnames(df_tail)) {
      out[[f]] <- df_tail[[f]][1]  # el threshold NO se promedia
    }
  }

  return(out)
}

transformar_a_U <- function(x, marginal) {

  tipo   <- marginal$model_type
  nombre <- tolower(marginal$model_name)
  params <- marginal$params

  # =====================
  # TAIL PARAMÉTRICA
  # =====================
  if (tipo == "tail") {

    # -------- BURR --------
    if (nombre == "burr") {
      Fx <- pburr(
        q = x,
        shape1 = params[1],
        shape2 = params[2],
        scale  = params[3]
      )
    }

    # -------- GPD --------
    else if (nombre == "gpd") {
      Fx <- pgpd(
        x    = x,
        xi   = params[1],
        beta = params[2],
        u0   = marginal$u_opt
      )
    }

    # -------- PARETO --------
    else if (nombre == "pareto") {
      Fx <- ppareto(
        x     = x,
        shape = params[1],
        scale = params[2]
      )
    }

    # -------- LOGNORMAL _TAIL --------
    else if (nombre == "ln_tail" || nombre == "lognormal") {
      Fx <- plnorm(
        x,
        meanlog = params[1],
        sdlog   = params[2]
      )
    }

    else {
      stop("Distribución tail no implementada: ", nombre)
    }
  }


  # =====================
  # BODY / KDE  (SI QUISIERAS USARLO)
  # =====================
  else if (tipo == "body") {

    xgrid <- marginal$x
    fgrid <- marginal$dens
    Fx <- approx(
      x = xgrid,
      y = cumsum(fgrid) / sum(fgrid),
      xout = x,
      rule = 2
    )$y
  }

  else {
    stop("Tipo marginal desconocido.")
  }

  # VALIDACIÓN
  if (any(is.na(Fx)) || any(is.infinite(Fx))) {
    message("[Aviso] Fx inválido → usando U empírica.")
    Fx <- rank(x) / (length(x) + 1)
  }

  ks <- suppressWarnings(ks.test(Fx, "punif"))
  if (ks$p.value < 0.05) {
    message("[Aviso] KS no pasa → usando U empírica.")

  # =======================================
  # 2. TAIL / PARAMÉTRICO
  # =======================================
  else if (tipo %in% c("tail", "param")) {

    if (nombre == "burr") {
      Fx <- pburr(
        q      = x,
        shape1 = marginal$param1,
        shape2 = marginal$param2,
        scale  = marginal$param3
      )
    }

    else if (nombre == "gpd") {
      Fx <- pgpd(
        x    = x,
        xi   = marginal$param1,
        beta = marginal$param2,
        u0   = marginal$u_opt
      )
    }

    else if (nombre == "pareto") {
      Fx <- ppareto(
        x     = x,
        shape = marginal$param1,
        scale = marginal$param2
      )
    }

    else if (nombre == "ln_tail" || nombre == "lognormal") {
      Fx <- plnorm(
        x,
        meanlog = marginal$param1,
        sdlog   = marginal$param2
      )
    }

    else {
      stop("Distribución paramétrica no implementada: ", marginal$model_name)
    }
  }

  else {
    stop("Tipo marginal desconocido.")
  }

  # VALIDACIÓN
  if (any(is.na(Fx)) || any(is.infinite(Fx))) {
    message("[Aviso] Fx inválido → usando U empírica.")
    Fx <- rank(x) / (length(x) + 1)
  }

  ks <- suppressWarnings(ks.test(Fx, "punif"))
  if (ks$p.value < 0.05) {
    message("[Aviso] KS no pasa → usando U empírica.")
    Fx <- rank(x) / (length(x) + 1)
  }

  return(Fx)
}


transformar_desde_U <- function(U, marginal) {

  tipo   <- marginal$model_type
  nombre <- tolower(marginal$model_name)
  params <- marginal$params

  if (tipo == "tail") {
  tipo   <- tolower(marginal$model_type)
  nombre <- tolower(marginal$model_name)
  params <- marginal$params

  if (tipo == "tail") {

    if (nombre == "burr") {
      return(qburr(
        p      = U,

        shape1 = params[1],
        shape2 = params[2],
        scale  = params[3],
        shape1 = marginal$param1,
        shape2 = marginal$param2,
        scale  = marginal$param3
        shape1 = params[1],
        shape2 = params[2],
        scale  = params[3]
      ))
    }

    if (nombre == "gpd") {
      return(qgpd(
        p    = U,
        xi   = params[1],
        beta = params[2],
        xi   = marginal$param1,
        beta = marginal$param2,

        u0   = marginal$u_opt
      ))
    }

    if (nombre == "pareto") {
      return(qpareto(
        p     = U,
        shape = params[1],
        scale = params[2],
        shape = marginal$param1,
        scale = marginal$param2
        scale = params[2]
      ))
    }

    if (nombre == "ln_tail" || nombre == "lognormal") {
      return(qlnorm(
        p      = U,
        meanlog = params[1],
        sdlog   = params[2]
      ))
    }

    stop("Tail no implementado: ", nombre)
  }

  else if (tipo == "body") {
    xgrid <- marginal$x
    fgrid <- marginal$dens
    dx <- xgrid[2] - xgrid[1]
    cdf <- cumsum(fgrid) * dx
    cdf <- cdf / max(cdf)
    qfun <- approxfun(cdf, xgrid, rule = 2)
    return(qfun(U))
  }

  stop("Tipo marginal desconocido.")
}

        meanlog = marginal$param1,
        sdlog   = marginal$param2
      ))
    }

    stop("Tail no implementado: ", nombre)
  }

  else if (tipo == "body") {
    xgrid <- marginal$x
    fgrid <- marginal$dens
    dx <- xgrid[2] - xgrid[1]
    cdf <- cumsum(fgrid) * dx
    cdf <- cdf / max(cdf)
    qfun <- approxfun(cdf, xgrid, rule = 2)
    return(qfun(U))
  }

  stop("Tipo marginal desconocido.")
}

```

## Pipes para correr todo

```{r}
simular_provincia_sector <- function(
    provincia,
    sector,
    df_evento_provincias,
    df_evento_sectores,
    path_marg = "../res/marginales",
    n_sim = 50000,
    alpha = 0.95
){

  message("\n========== SIMULACIÓN PROVINCIA–SECTOR ==========")
  message("Provincia: ", provincia, " — Sector: ", sector)

  df_pair <- construir_par_prov_sector(
    df_evento_provincias,
    df_evento_sectores,
    provincia,
    sector
  )

  if (is.null(df_pair) || nrow(df_pair) < 10) {
    message("[Aviso] Muy pocos datos para esta combinación.")
    return(NULL)
  }

  m_prov <- leer_marginal(file.path(path_marg, "provincias", provincia))
  m_sec  <- leer_marginal(file.path(path_marg, "sectores",   sector))

  U1 <- transformar_a_U(df_pair$X, m_prov)
  U2 <- transformar_a_U(df_pair$Y, m_sec)

  U <- cbind(U1, U2)
  colnames(U) <- c("U1", "U2")

  fit <- BiCopSelect(
    u1 = U[,1],
    u2 = U[,2],
    familyset = c(1,2,3,4,5),
    selectioncrit = "AIC"
  )

  message("Cópula seleccionada: ",
          BiCopName(fit$family),
          " (par = ", round(fit$par, 3), ")")

  U_sim <- BiCopSim(
    N      = n_sim,
    family = fit$family,
    par    = fit$par,
    par2   = fit$par2
  )

  X_sim <- transformar_desde_U(U_sim[,1], m_prov)
  Y_sim <- transformar_desde_U(U_sim[,2], m_sec)

  S_sim <- X_sim + Y_sim

  VaR_X <- quantile(X_sim, alpha, na.rm = TRUE)
  VaR_Y <- quantile(Y_sim, alpha, na.rm = TRUE)
  VaR_S <- quantile(S_sim, alpha, na.rm = TRUE)

  CVaR_S <- mean(S_sim[S_sim > VaR_S], na.rm = TRUE)

  list(
    provincia = provincia,
    sector    = sector,
    fit   = fit,
    U     = U,
    U_sim = U_sim,
    X_sim = X_sim,
    Y_sim = Y_sim,
    VaR_X = VaR_X,
    VaR_Y = VaR_Y,
    VaR_S = VaR_S,
    CVaR_S = CVaR_S
  )
}


simular_par <- function(
  df_A, df_B,
  varA, varB,
  tipoA, tipoB,      # "provincias", "sectores", "categorias"
  path_marg = "../res/marginales",
  alpha = 0.95,
  n_sim = 50000
){

  message("\n====== SIMULACIÓN ", tipoA, " – ", tipoB, " ======")
  message(varA, " — ", varB)

  # 1. Construir par
  df_pair <- construir_par(df_A, df_B, varA, varB)
  if (is.null(df_pair)) return(NULL)

  # 2. Leer marginales
  mA <- leer_marginal(file.path(path_marg, tipoA, varA))
  mB <- leer_marginal(file.path(path_marg, tipoB, varB))

  # 3. Transformación a U
  U1 <- transformar_a_U(df_pair$X, mA)
  U2 <- transformar_a_U(df_pair$Y, mB)

  U <- cbind(U1, U2)

  # 4. Ajustar cópula
  fit <- BiCopSelect(
    u1 = U[,1], u2 = U[,2],
    familyset = c(1,2,3,4,5),
    selectioncrit = "AIC"
  )

  # 5. Simulación
  U_sim <- BiCopSim(
    N = n_sim,
    family = fit$family,
    par = fit$par,
    par2 = fit$par2
  )

  # 6. Transformación inversa
  X_sim <- transformar_desde_U(U_sim[,1], mA)
  Y_sim <- transformar_desde_U(U_sim[,2], mB)

  S <- X_sim + Y_sim

  # 7. Métricas
  list(
    tipoA = tipoA, tipoB = tipoB,
    varA = varA, varB = varB,
    copula = BiCopName(fit$family),
    par = fit$par,
    tau = BiCopPar2Tau(fit$family, fit$par),
    VaR_A = quantile(X_sim, alpha),
    VaR_B = quantile(Y_sim, alpha),
    VaR_S = quantile(S, alpha),
    CVaR_S = mean(S[S > quantile(S, alpha)], na.rm = TRUE)
  )
}



tabla_dependencias_prov_sector <- function(
    df_evento_provincias,
    df_evento_sectores,
    path_marg = "../res/marginales"
){

  resultados <- list()

  for (prov in colnames(df_evento_provincias)[-1]) {
    for (sec in colnames(df_evento_sectores)[-1]) {

      fit_ps <- try(
        simular_provincia_sector(
          provincia = prov,
          sector    = sec,
          df_evento_provincias = df_evento_provincias,
          df_evento_sectores   = df_evento_sectores,
          path_marg = path_marg,
          n_sim     = 2000
        ),
        silent = TRUE
      )

      if (inherits(fit_ps, "try-error") || is.null(fit_ps)) next

      tau <- BiCopPar2Tau(fit_ps$fit$family, fit_ps$fit$par)

      resultados[[paste(prov,sec,sep="_")]] <- data.frame(
        provincia = prov,
        sector    = sec,
        copula    = BiCopName(fit_ps$fit$family),
        par       = fit_ps$fit$par,
        tau       = tau
      )
    }
  }

  dplyr::bind_rows(resultados)
}


graficar_sim_vs_real <- function(result){
  par(mfrow=c(1,3))
  hist(result$X_sim, main=paste("Sim X -", result$provincia), col="skyblue")
  hist(result$Y_sim, main=paste("Sim Y -", result$sector),    col="salmon")
  hist(result$X_sim + result$Y_sim, main="Suma simulada",     col="orchid")
}

graficar_heatmap_tau <- function(tab){
  mat <- tidyr::pivot_wider(
    tab,
    names_from = sector,
    values_from = tau,
    id_cols = provincia
  )

  m <- as.matrix(mat[,-1])
  rownames(m) <- mat$provincia

  heatmap(m, Rowv=NA, Colv=NA, scale="none",
          col=colorRampPalette(c("white","red"))(20))
}

```


## Uso

```{r}
tab_ps <- tabla_dependencias_prov_sector(
  df_evento_provincias,
  df_evento_sectores
)
```

```{r}
tab
```

```{r}
tab_prov_sec <- expand.grid(
  prov = colnames(df_evento_provincias)[-1],
  sec  = colnames(df_evento_sectores)[-1],
  KEEP.OUT.ATTRS = FALSE
)

res_prov_sec <- purrr::map2_df(
  tab_prov_sec$prov,
  tab_prov_sec$sec,
  ~ simular_par(
      df_evento_provincias,
      df_evento_sectores,
      .x,
      .y,
      "provincias",
      "sectores") )
  tab_prov_sec$prov,
  tab_prov_sec$sec,
  ~ simular_par(df_evento_provincias, df_evento_sectores,
                .x, .y, "provincias", "sectores")
)


tab_prov_cat <- expand.grid(
  prov = colnames(df_evento_provincias)[-1],
  cat  = colnames(df_evento_categorias)[-1],
  KEEP.OUT.ATTRS = FALSE
)

res_prov_cat <- purrr::map2_df(
  tab_prov_cat$prov,
  tab_prov_cat$cat,
  ~ simular_par(
      df_evento_provincias,
      df_evento_categorias,
      .x,
      .y,
      "provincias",
      "categorias") )


tab_sec_cat <- expand.grid(
  sec = colnames(df_evento_sectores)[-1],
  cat = colnames(df_evento_categorias)[-1],
  KEEP.OUT.ATTRS = FALSE
)

res_sec_cat <- purrr::map2_df(
  tab_sec_cat$sec,
  tab_sec_cat$cat,
  ~ simular_par(
      df_evento_sectores,
      df_evento_categorias,
      .x,
      .y,
      "sectores",
      "categorias") )
```
```{r}
write.csv(res_prov_sec, '../res/copulas/provincia_sector.csv')
write.csv(res_prov_cat, '../res/copulas/provincia_categoria.csv')
write.csv(res_sec_cat, '../res/copulas/sector_categoria.csv')
```

```{r}
res_prov_sec <- read.csv('../res/copulas/provincia_sector.csv')
res_prov_cat <- read.csv('../res/copulas/provincia_categoria.csv')
res_sec_cat <- read.csv('../res/copulas/sector_categoria.csv')

```


## VaR y CVaR

```{r}
riesgo_par <- function(nombre_x, nombre_y, carpeta_x, carpeta_y, fit,
                       base_path = "../res/marginales",
                       n = 50000, alpha = 0.95) {

  # cargar marginal X
  m1 <- leer_marginal(file.path(base_path, carpeta_x, nombre_x))

  # cargar marginal Y
  m2 <- leer_marginal(file.path(base_path, carpeta_y, nombre_y))

  # calcular riesgos
  calcular_var_cvar_par(fit, m1, m2, n = n)
}


calcular_var_cvar_par <- function(fit, m1, m2, n = 50000) {

  # 1. Simular U desde la cópula
  U_sim <- BiCopSim(
    N      = n,
    family = fit$family,
    par    = fit$par,
    par2   = fit$par2
  )

  U1 <- U_sim[,1]
  U2 <- U_sim[,2]

  # 2. Transformar a X,Y con las marginales
  X_sim <- transformar_desde_U(U1, m1)
  Y_sim <- transformar_desde_U(U2, m2)

  # 3. Suma conjunta
  S_sim <- X_sim + Y_sim

  # --- niveles de confianza ---
  alphas <- c(0.95, 0.99)

  # --- listas de resultados ---
  out <- list()

  for (a in alphas) {

    # VaR individuales
    VaR_X <- quantile(X_sim, a, na.rm = TRUE)
    VaR_Y <- quantile(Y_sim, a, na.rm = TRUE)

    # VaR conjunto
    VaR_S <- quantile(S_sim, a, na.rm = TRUE)

    # CVaR conjunto
    CVaR_S <- mean(S_sim[S_sim >= VaR_S], na.rm = TRUE)

    # CVaR condicional: Y | X >= VaR_X
    CVaR_cond <- mean(Y_sim[X_sim >= VaR_X], na.rm = TRUE)

    # guardar con nombres específicos
    suf <- ifelse(a == 0.95, "95", "99")

    out[[paste0("VaR_X_", suf)]]       <- VaR_X
    out[[paste0("VaR_Y_", suf)]]       <- VaR_Y
    out[[paste0("VaR_Cop_", suf)]]     <- VaR_S
    out[[paste0("CVaR_Cop_", suf)]]    <- CVaR_S
    out[[paste0("CVaR_cond_", suf)]]   <- CVaR_cond
  }

  return(out)
}


```

```{r}
res_prov_sec_riesgo <- res_prov_sec %>%
  rowwise() %>%
  mutate(
    riesgo = list(
      riesgo_par(
        nombre_x  = varA,
        nombre_y  = varB,
        carpeta_x = tipoA,
        carpeta_y = tipoB,
        fit       = fit
      )
    )
  ) %>%
  unnest_wider(riesgo) %>%
  ungroup()

res_prov_cat_riesgo <- res_prov_cat %>%
  rowwise() %>%
  mutate(
    riesgo = list(
      riesgo_par(
        nombre_x  = varA,
        nombre_y  = varB,
        carpeta_x = tipoA,
        carpeta_y = tipoB,
        fit       = fit
      )
    )
  ) %>%
  unnest_wider(riesgo) %>%
  ungroup()


res_sec_cat_riesgo <- res_sec_cat %>%
  rowwise() %>%
  mutate(
    riesgo = list(
      riesgo_par(
        nombre_x  = varA,
        nombre_y  = varB,
        carpeta_x = tipoA,
        carpeta_y = tipoB,
        fit       = fit
      )
    )
  ) %>%
  unnest_wider(riesgo) %>%
  ungroup()


```
```{r}
write.csv(res_prov_sec, '../res/copulas/provincia_sector.csv')
write.csv(res_prov_cat, '../res/copulas/provincia_categoria.csv')
write.csv(res_sec_cat, '../res/copulas/sector_categoria.csv')
```

```{r}
res_prov_sec <- read.csv('../res/copulas/provincia_sector.csv')
res_prov_cat <- read.csv('../res/copulas/provincia_categoria.csv')
res_sec_cat <- read.csv('../res/copulas/sector_categoria.csv')

```


## VaR y CVaR

```{r}
riesgo_par <- function(nombre_x, nombre_y, carpeta_x, carpeta_y, fit,
                       base_path = "../res/marginales",
                       n = 50000, alpha = 0.95) {

  # cargar marginal X
  m1 <- leer_marginal(file.path(base_path, carpeta_x, nombre_x))

  # cargar marginal Y
  m2 <- leer_marginal(file.path(base_path, carpeta_y, nombre_y))

  # calcular riesgos
  calcular_var_cvar_par(fit, m1, m2, n = n)
}


calcular_var_cvar_par <- function(fit, m1, m2, n = 50000) {

  # 1. Simular U desde la cópula
  U_sim <- BiCopSim(
    N      = n,
    family = fit$family,
    par    = fit$par,
    par2   = fit$par2
  )

  U1 <- U_sim[,1]
  U2 <- U_sim[,2]

  # 2. Transformar a X,Y con las marginales
  X_sim <- transformar_desde_U(U1, m1)
  Y_sim <- transformar_desde_U(U2, m2)

  # 3. Suma conjunta
  S_sim <- X_sim + Y_sim

  # --- niveles de confianza ---
  alphas <- c(0.95, 0.99)

  # --- listas de resultados ---
  out <- list()

  for (a in alphas) {

    # VaR individuales
    VaR_X <- quantile(X_sim, a, na.rm = TRUE)
    VaR_Y <- quantile(Y_sim, a, na.rm = TRUE)

    # VaR conjunto
    VaR_S <- quantile(S_sim, a, na.rm = TRUE)

    # CVaR conjunto
    CVaR_S <- mean(S_sim[S_sim >= VaR_S], na.rm = TRUE)

    # CVaR condicional: Y | X >= VaR_X
    CVaR_cond <- mean(Y_sim[X_sim >= VaR_X], na.rm = TRUE)

    # guardar con nombres específicos
    suf <- ifelse(a == 0.95, "95", "99")

    out[[paste0("VaR_X_", suf)]]       <- VaR_X
    out[[paste0("VaR_Y_", suf)]]       <- VaR_Y
    out[[paste0("VaR_Cop_", suf)]]     <- VaR_S
    out[[paste0("CVaR_Cop_", suf)]]    <- CVaR_S
    out[[paste0("CVaR_cond_", suf)]]   <- CVaR_cond
  }

  return(out)
}


```

```{r}
res_prov_sec_riesgo <- res_prov_sec %>%
  rowwise() %>%
  mutate(
    riesgo = list(
      riesgo_par(
        nombre_x  = varA,
        nombre_y  = varB,
        carpeta_x = tipoA,
        carpeta_y = tipoB,
        fit       = fit
      )
    )
  ) %>%
  unnest_wider(riesgo) %>%
  ungroup()

res_prov_cat_riesgo <- res_prov_cat %>%
  rowwise() %>%
  mutate(
    riesgo = list(
      riesgo_par(
        nombre_x  = varA,
        nombre_y  = varB,
        carpeta_x = tipoA,
        carpeta_y = tipoB,
        fit       = fit
      )
    )
  ) %>%
  unnest_wider(riesgo) %>%
  ungroup()


res_sec_cat_riesgo <- res_sec_cat %>%
  rowwise() %>%
  mutate(
    riesgo = list(
      riesgo_par(
        nombre_x  = varA,
        nombre_y  = varB,
        carpeta_x = tipoA,
        carpeta_y = tipoB,
        fit       = fit
      )
    )
  ) %>%
  unnest_wider(riesgo) %>%
  ungroup()

```


```{r}

write.csv(res_prov_sec_riesgo, '../res/copulas/VAR_provincia_sector.csv')
write.csv(res_prov_cat_riesgo, '../res/copulas/VAR_provincia_categoria.csv')
write.csv(res_sec_cat_riesgo, '../res/copulas/VAR_sector_categoria.csv')
```

## GRAFICOS

```{r}
colnames(res_prov_sec_riesgo)
```
```{r}

library(ggplot2)

plot_heatmap_tau <- function(df, titulo = "Mapa de correlación (tau)") {
  library(dplyr)
  library(tidyr)
  library(ggplot2)

  df_wide <- df %>%
    select(varA, varB, tau) %>%
    tidyr::pivot_wider(
      names_from  = varB,
      values_from = tau
    )

  df_long <- df_wide %>%
    tidyr::pivot_longer(
      cols      = -varA,
      names_to  = "varB",
      values_to = "tau"
    )

  ggplot(df_long, aes(x = varB, y = varA, fill = tau)) +
    geom_tile(color = "white") +
    # Paleta de amarillos
    scale_fill_gradient(
      low      = "#FFF9C4",  # amarillo muy claro
      high     = "#FBC02D",  # amarillo intenso
      na.value = "grey90"
    ) +
    # Etiquetas de valor encima de la casilla
    geom_text(aes(label = round(tau, 2)),
              color = "black",
              size  = 3.5,
              na.rm = TRUE) +
    labs(
      title = titulo,
      x     = "Variable B",
      y     = "Variable A",
      fill  = "Tau"
    ) +
    theme_minimal(base_size = 13) +
    theme(
      axis.text.x  = element_text(angle = 45, hjust = 1),
      panel.grid   = element_blank(),
      plot.title   = element_text(face = "bold", hjust = 0.5)
    )
}


```


```{r}
plot_heatmap_tau(res_prov_sec_riesgo, "Tau: Provincias vs Sectores")
plot_heatmap_tau(res_prov_cat_riesgo, "Tau: Provincias vs Categorías")
plot_heatmap_tau(res_sec_cat_riesgo, "Tau: Sectores vs Categorías")

```

```{r}
library(VineCopula)

copula_familia <- function(name){
  switch(name,
    "N"  = 1,
    "t"  = 2,
    "C"  = 3,
    "G"  = 4,
    "F"  = 5,
    "SC" = 3,   # Clayton survival
    "SG" = 4,   # Gumbel survival
    0     # default
  )
}

tail_dep <- function(family, par, par2 = NA) {

  fam <- BiCopName(family, short = TRUE)

  # Inicializar
  lambda_L <- lambda_U <- 0

  if (fam == "C") {           # Clayton
    theta <- par
    lambda_L <- 2^(-1/theta)
    lambda_U <- 0
  }
  else if (fam == "G") {      # Gumbel
    theta <- par
    lambda_L <- 0
    lambda_U <- 2 - 2^(1/theta)
  }
  else if (fam == "F") {      # Frank
    lambda_L <- 0
    lambda_U <- 0
  }
  else if (fam == "N") {      # Gaussian
    lambda_L <- 0
    lambda_U <- 0
  }
  else if (fam == "t") {      # Student t
    rho <- par
    nu  <- par2
    t_val <- sqrt( ((nu + 1)*(1 - rho))/(1 + rho) )
    lambda <- 2 * pt(-t_val, df = nu + 1)
    lambda_L <- lambda
    lambda_U <- lambda
  }

  return(list(lambda_L = lambda_L, lambda_U = lambda_U))
}

```


```{r}
res_prov_sec_tail <- res_prov_sec %>%
  rowwise() %>%
  mutate(
    tail = list(
      tail_dep(
        family = copula_familia(copula),
        par    = par,
        par2   = ifelse("par2" %in% names(.), par2, NA)
      )
    )
  ) %>%
  unnest_wider(tail)

res_prov_cat_tail <- res_prov_cat %>%
  rowwise() %>%
  mutate(
    tail = list(
      tail_dep(
        family = copula_familia(copula),
        par    = par,
        par2   = ifelse("par2" %in% names(.), par2, NA)
      )
    )
  ) %>%
  unnest_wider(tail)


res_sec_cat_tail <- res_sec_cat %>%
  rowwise() %>%
  mutate(
    tail = list(
      tail_dep(
        family = copula_familia(copula),
        par    = par,
        par2   = ifelse("par2" %in% names(.), par2, NA)
      )
    )
  ) %>%
  unnest_wider(tail)


```


```{r}
plot_heatmap_tail <- function(df,
                              titulo = "Dependencia de cola"){

  library(dplyr)
  library(tidyr)
  library(ggplot2)
  library(rlang)

  cola <- 'inferior'
  col_sel <- 'lambda_L'

  df_wide <- df %>%
    dplyr::select(varA, varB, !!sym(col_sel)) %>%
    tidyr::pivot_wider(
      names_from  = varB,
      values_from = !!sym(col_sel)
    )

  df_long <- df_wide %>%
    tidyr::pivot_longer(
      cols      = -varA,
      names_to  = "varB",
      values_to = "lambda"
    )

  ggplot(df_long, aes(x = varB, y = varA, fill = lambda)) +
    geom_tile(color = "white") +
    # Paleta de amarillos
    scale_fill_gradient(
      low      = "#FFF9C4",   # amarillo muy claro
      high     = "#FBC02D",   # amarillo intenso
      na.value = "grey90"
    ) +
    # Número sobre la casilla
    geom_text(aes(label = round(lambda, 2)),
              color = "black",
              size  = 3.5,
              na.rm = TRUE) +
    labs(
      title = titulo,
      x     = "Variable B",
      y     = "Variable A",
      fill  = paste0("λ_", ifelse(cola=="inferior","L","U"))
    ) +
    theme_minimal(base_size = 13) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid  = element_blank(),
      plot.title  = element_text(face = "bold", hjust = 0.5)
    )
}

```

```{r}
plot_heatmap_tail(res_prov_sec_tail,
                  titulo = "Dependencia de cola superior (λ_U)")

plot_heatmap_tail(res_prov_cat_tail,
                  titulo = "Dependencia de cola superior (λ_U)")

plot_heatmap_tail(res_sec_cat_tail,
                  titulo = "Dependencia de cola superior (λ_U)")


```

```{r}
library(dplyr)
library(tidyr)
library(ggplot2)
library(rlang)

plot_heatmap_metric <- function(df, metric, titulo = NULL) {

  if (is.null(titulo)) {
    titulo <- paste("Heatmap de", metric)
  }

  df_wide <- df %>%
    dplyr::select(varA, varB, !!sym(metric)) %>%
    tidyr::pivot_wider(
      names_from  = varB,
      values_from = !!sym(metric)
    )

  df_long <- df_wide %>%
    tidyr::pivot_longer(
      cols      = -varA,
      names_to  = "varB",
      values_to = "value"
    )

  ggplot(df_long, aes(x = varB, y = varA, fill = value)) +
    geom_tile(color = "white") +
    # Paleta secuencial de rojos
    scale_fill_gradient(
      low      = "#FFEBEE",   # rojo muy claro
      high     = "#C62828",   # rojo intenso
      na.value = "grey90"
    ) +
    # Número sobre la casilla
    geom_text(aes(label = round(value, 2)),
              color = "black",
              size  = 3.5,
              na.rm = TRUE) +
    labs(
      title = titulo,
      x     = "Variable B",
      y     = "Variable A",
      fill  = metric
    ) +
    theme_minimal(base_size = 13) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid  = element_blank(),
      plot.title  = element_text(face = "bold", hjust = 0.5)
    )
}


```


```{r}
plot_heatmap_metric(res_prov_sec_riesgo, "VaR_Cop_95",
                    "VaR conjunto 95%")
plot_heatmap_metric(res_prov_cat_riesgo, "VaR_Cop_95",
                    "VaR conjunto 95%")
plot_heatmap_metric(res_sec_cat_riesgo, "VaR_Cop_95",
                    "VaR conjunto 95%")

plot_heatmap_metric(res_prov_sec_riesgo, "VaR_Cop_99",
                    "VaR conjunto 99%")
plot_heatmap_metric(res_prov_cat_riesgo, "VaR_Cop_99",
                    "VaR conjunto 99%")
plot_heatmap_metric(res_sec_cat_riesgo, "VaR_Cop_99",
                    "VaR conjunto 99%")


```

```{r}
plot_heatmap_metric <- function(df, metric, titulo = NULL) {

  if (is.null(titulo)) {
    titulo <- paste("Heatmap de", metric)
  }

  df_wide <- df %>%
    dplyr::select(varA, varB, !!sym(metric)) %>%
    tidyr::pivot_wider(
      names_from  = varB,
      values_from = !!sym(metric)
    )

  df_long <- df_wide %>%
    tidyr::pivot_longer(
      cols      = -varA,
      names_to  = "varB",
      values_to = "value"
    )

  ggplot(df_long, aes(x = varB, y = varA, fill = value)) +
    geom_tile(color = "white") +
    # Paleta secuencial de rojos
    scale_fill_gradient(
      low      = "#FFF3E0",   # naranja muy claro
      high     = "#EF6C00",   # naranja intenso
      na.value = "grey90"
    ) +
    # Número sobre la casilla
    geom_text(aes(label = round(value, 2)),
              color = "black",
              size  = 3.5,
              na.rm = TRUE) +
    labs(
      title = titulo,
      x     = "Variable B",
      y     = "Variable A",
      fill  = metric
    ) +
    theme_minimal(base_size = 13) +
    theme(
      axis.text.x = element_text(angle = 45, hjust = 1),
      panel.grid  = element_blank(),
      plot.title  = element_text(face = "bold", hjust = 0.5)
    )
}


```




```{r}
plot_heatmap_metric(res_prov_sec_riesgo, "CVaR_Cop_95",
                    "CVaR conjunto 95%")
plot_heatmap_metric(res_prov_cat_riesgo, "CVaR_Cop_95",
                    "CVaR conjunto 95%")
plot_heatmap_metric(res_sec_cat_riesgo, "CVaR_Cop_95",
                    "CVaR conjunto 95%")

plot_heatmap_metric(res_prov_sec_riesgo, "CVaR_Cop_99",
                    "CVaR conjunto 99%")
plot_heatmap_metric(res_prov_cat_riesgo, "CVaR_Cop_99",
                    "CVaR conjunto 99%")
plot_heatmap_metric(res_sec_cat_riesgo, "CVaR_Cop_99",
                    "CVaR conjunto 99%")


tab_prov_cat
res_sec_cat

```
