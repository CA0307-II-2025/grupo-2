---
title: "3_copulas_limpio"
format: html
---

```{r}
# ============================
# PAQUETES NECESARIOS
# ============================
library(evmix)      # EVT híbrida
library(copula)     # cópulas (t, gumbel)
library(dplyr)
library(purrr)
library(readr)
library(tibble)

# ============================
# 1. CARGA DE MARGINAL BODY + TAIL
# ============================

load_body <- function(name, carpeta) {
  archivos <- list.files(carpeta, pattern = paste0("^", name, "_body"), full.names = TRUE)
  if (length(archivos) == 0) stop(paste("No body para", name))
  read_csv(archivos[1], show_col_types = FALSE)
}

load_tail <- function(name, carpeta) {
  archivos <- list.files(carpeta, pattern = paste0("^", name, "_tail"), full.names = TRUE)
  if (length(archivos) == 0) stop(paste("No tail para", name))
  read_csv(archivos[1], show_col_types = FALSE)
}

# ============================
# 2. CDF HÍBRIDA (BODY + EVT)
# ============================

F_hybrid <- function(x, body_sample, tail) {
  u <- tail$u_opt[1]     # umbral
  p_u <- tail$p_u[1] # prob. de excedencia

  if (x <= u) {
    mean(body_sample <= x) * (1 - p_u)
  } else {
    # CDF EVT (GPD, Burr, LN, etc.) usando evmix
    xi  <- tail$shape[1]
    beta <- tail$scale[1]
    F_exc <- pgpd((x - u), xi = xi, beta = beta)
    (1 - p_u) + p_u * F_exc
  }
}

# ============================
# 3. CUANTIL HÍBRIDO (INVERSA)
# ============================

Q_hybrid <- function(p, body_sample, tail) {
  u  <- tail$u_opt[1]
  p_u <- tail$p_u[1]

  if (p <= (1 - p_u)) {
    quantile(body_sample, probs = p / (1 - p_u))
  } else {
    xi  <- tail$shape[1]
    beta <- tail$scale[1]
    q_exc <- qgpd((p - (1 - p_u))/p_u, xi = xi, beta = beta)
    u + q_exc
  }
}

# ============================
# 4. U-VARIABLE (TRANSFORMACIÓN X → U)
# ============================

U_variable <- function(x, name, carpeta) {
  body <- load_body(name, carpeta)
  tail <- load_tail(name, carpeta)

  u <- tail$u_opt[1]

  body_sample <- x[x <= u]
  U <- map_dbl(x, ~ F_hybrid(.x, body_sample, tail))

  list(U = U, body_sample = body_sample, tail = tail)
}

# ============================
# 5. AJUSTE DE CÓPULAS (T Y GUMBEL)
# ============================

fit_copulas <- function(U1, U2) {
  datos <- cbind(U1, U2)

  # Copula t
  cop_t <- tCopula(dim = 2, dispstr = "un")
  fit_t <- fitCopula(cop_t, datos, method="ml")
  aic_t <- AIC(fit_t)

  # Copula Gumbel
  cop_g <- gumbelCopula(dim = 2)
  fit_g <- fitCopula(cop_g, datos, method="ml")
  aic_g <- AIC(fit_g)

  winner <- ifelse(aic_t < aic_g, "t", "gumbel")

  list(winner = winner, fit_t = fit_t, fit_g = fit_g)
}

# ============================
# 6. SIMULACIÓN DE LA CÓPULA GANADORA
# ============================

simulate_copula <- function(fit_obj, n) {
  if (fit_obj$winner == "t") {
    rCopula(n, fit_obj$fit_t@copula)
  } else {
    rCopula(n, fit_obj$fit_g@copula)
  }
}

# ============================
# 7. SIMULACIÓN CONJUNTA X1 + X2
# ============================

simulate_joint_losses <- function(U_sim, body1, tail1, body2, tail2) {
  X1 <- map_dbl(U_sim[,1], ~ Q_hybrid(.x, body1, tail1))
  X2 <- map_dbl(U_sim[,2], ~ Q_hybrid(.x, body2, tail2))
  X1 + X2
}

# ============================
# 8. VaR Y CVaR
# ============================

var_cvar <- function(S, alpha) {
  VaR <- quantile(S, alpha)
  CVaR <- mean(S[S > VaR])
  list(VaR = VaR, CVaR = CVaR)
}

# ============================
# 9. PIPELINE PARA 1 PAREJA
# ============================

dependencia_y_riesgo <- function(df, col1, v1, carpeta1,
                                 col2, v2, carpeta2,
                                 n_sims = 200000,
                                 alphas = c(0.95, 0.99)) {

  df_pair <- df %>% filter(!!sym(col1) == v1, !!sym(col2) == v2)
  if (nrow(df_pair) < 50) return(NULL)

  # Marginal 1
  m1 <- U_variable(df_pair$total, v1, carpeta1)

  # Marginal 2
  m2 <- U_variable(df_pair$total, v2, carpeta2)

  # Ajustar cópulas
  fit <- fit_copulas(m1$U, m2$U)

  # Simular cópula
  U_sim <- simulate_copula(fit, n_sims)

  # Transformar a pérdidas
  S <- simulate_joint_losses(U_sim, m1$body_sample, m1$tail,
                             m2$body_sample, m2$tail)

  # VaR y CVaR
  res <- tibble(
    col1 = col1, valor1 = v1,
    col2 = col2, valor2 = v2,
    winner = fit$winner,
    VaR_95 = var_cvar(S, alphas[1])$VaR,
    CVaR_95 = var_cvar(S, alphas[1])$CVaR,
    VaR_99 = var_cvar(S, alphas[2])$VaR,
    CVaR_99 = var_cvar(S, alphas[2])$CVaR
  )

  res
}

# ============================
# 10. PIPELINE COMPLETO PARA TODAS LAS PAREJAS
# ============================

todas_dependencias <- function(df, provincias, categorias, sectores,
                               carpeta_prov, carpeta_cat, carpeta_sec,
                               n_sims = 200000,
                               alphas = c(0.95, 0.99)) {

  resultados <- list()

  # provincia-sector
  for (p in provincias) {
    for (s in sectores) {
      r <- dependencia_y_riesgo(df, "provincia", p, carpeta_prov,
                                "sector", s, carpeta_sec,
                                n_sims, alphas)
      if (!is.null(r)) {
        r$tipo <- "provincia-sector"
        resultados <- append(resultados, list(r))
      }
    }
  }

  # provincia-categoria
  for (p in provincias) {
    for (c in categorias) {
      r <- dependencia_y_riesgo(df, "provincia", p, carpeta_prov,
                                "categoria", c, carpeta_cat,
                                n_sims, alphas)
      if (!is.null(r)) {
        r$tipo <- "provincia-categoria"
        resultados <- append(resultados, list(r))
      }
    }
  }

  # categoria-sector
  for (c in categorias) {
    for (s in sectores) {
      r <- dependencia_y_riesgo(df, "categoria", c, carpeta_cat,
                                "sector", s, carpeta_sec,
                                n_sims, alphas)
      if (!is.null(r)) {
        r$tipo <- "categoria-sector"
        resultados <- append(resultados, list(r))
      }
    }
  }

  bind_rows(resultados)
}


# GPD: params = (sigma, xi)
F_exc_gpd <- function(y, sigma, xi) {
  if (y <= 0) return(0)
  if (abs(xi) < 1e-12) {
    return(1 - exp(-y / sigma))
  } else {
    base <- 1 + xi * y / sigma
    if (base <= 0) return(1)  # fuera de soporte si cola truncada
    return(1 - base^(-1/xi))
  }
}

Q_exc_gpd <- function(p, sigma, xi) {
  p <- pmin(pmax(p, 1e-12), 1-1e-12)
  if (abs(xi) < 1e-12) {
    return(-sigma * log(1 - p))
  } else {
    return(sigma/xi * ((1 - p)^(-xi) - 1))
  }
}

# Burr XII: params = (c, k, lambda)
F_exc_burr <- function(y, c, k, lambda) {
  if (y <= 0) return(0)
  1 - (1 + (y / lambda)^c)^(-k)
}

Q_exc_burr <- function(p, c, k, lambda) {
  p <- pmin(pmax(p, 1e-12), 1-1e-12)
  inner <- (1 - p)^(-1/k) - 1
  inner <- pmax(inner, 0)
  lambda * (inner^(1/c))
}

# Pareto: params = (xm, alpha)
F_exc_pareto <- function(y, xm, alpha) {
  if (y <= 0) return(0)
  1 - (xm / (xm + y))^alpha
}

Q_exc_pareto <- function(p, xm, alpha) {
  p <- pmin(pmax(p, 1e-12), 1-1e-12)
  xm * ((1 - p)^(-1/alpha) - 1)
}

# Pareto Max sobre X (no sobre excedencias): params = (alpha, y0)
F_pareto_max <- function(x, alpha, y0) {
  if (x <= y0) return(0)
  1 - (y0 / x)^alpha
}

Q_pareto_max <- function(p, alpha, y0) {
  p <- pmin(pmax(p, 1e-12), 1-1e-12)
  y0 / (1 - p)^(1/alpha)
}

# Lognormal: params = (mu, sigma)
F_exc_lognormal <- function(y, mu, sigma) {
  if (y <= 0) return(0)
  plnorm(y, meanlog = mu, sdlog = sigma)
}

Q_exc_lognormal <- function(p, mu, sigma) {
  p <- pmin(pmax(p, 1e-12), 1-1e-12)
  qlnorm(p, meanlog = mu, sdlog = sigma)
}

# Gamma: params = (shape, scale)
F_exc_gamma <- function(y, shape, scale) {
  if (y <= 0) return(0)
  pgamma(y, shape = shape, scale = scale)
}

Q_exc_gamma <- function(p, shape, scale) {
  p <- pmin(pmax(p, 1e-12), 1-1e-12)
  qgamma(p, shape = shape, scale = scale)
}

# Weibull: params = (shape, scale)
F_exc_weibull <- function(y, shape, scale) {
  if (y <= 0) return(0)
  1 - exp(-(y / scale)^shape)
}

Q_exc_weibull <- function(p, shape, scale) {
  p <- pmin(pmax(p, 1e-12), 1-1e-12)
  scale * (-log(1 - p))^(1/shape)
}

# Fisk / Log-logistic: params = (shape, scale)
F_exc_fisk <- function(y, shape, scale) {
  if (y <= 0) return(0)
  1 - 1 / (1 + (y / scale)^shape)
}

Q_exc_fisk <- function(p, shape, scale) {
  p <- pmin(pmax(p, 1e-12), 1-1e-12)
  scale * (p / (1 - p))^(1/shape)
}

# KDE: grid x, dens f (en espacio de excedencias y)
F_exc_kde <- function(y, xs, fs) {
  if (y <= 0) return(0)
  ord <- order(xs)
  xs <- xs[ord]; fs <- fs[ord]
  num <- sum(fs[xs <= y])
  den <- sum(fs)
  if (den <= 0) return(0)
  num / den
}

Q_exc_kde <- function(p, xs, fs) {
  p <- pmin(pmax(p, 1e-12), 1-1e-12)
  ord <- order(xs)
  xs <- xs[ord]; fs <- fs[ord]
  cdf <- cumsum(fs) / sum(fs)
  idx <- which(cdf >= p)[1]
  if (is.na(idx)) return(max(xs))
  xs[idx]
}

get_params_from_tail <- function(tail_row) {
  cols_param <- grepl("_param", names(tail_row))
  as.numeric(tail_row[cols_param])
}


F_hybrid <- function(x, body_sample, tail) {
  # tail: data.frame de UNA fila con columnas:
  # model_name, model_type, u_opt, p_u, ..._param1, ..._param2, ...

  u   <- tail$u_opt[1]
  p_u <- tail$p_u[1]
  model <- tolower(tail$model_name[1])

  # Parte "body" empírica
  if (x <= u) {
    # Escalamos por (1 - p_u) para que justo antes de u la masa sea 1 - p_u
    return(mean(body_sample <= x, na.rm = TRUE) * (1 - p_u))
  }

  # Excedencia en la cola
  y <- x - u
  params <- get_params_from_tail(tail)

  # Cola según modelo
  F_exc <- switch(
    model,

    "gpd" = F_exc_gpd(y, sigma = params[1], xi = params[2]),

    "burr" = F_exc_burr(y, c = params[1], k = params[2], lambda = params[3]),

    "pareto" = F_exc_pareto(y, xm = params[1], alpha = params[2]),

    "pareto_max" = {  # aquí la definimos en escala X directamente
      # params = (alpha, y0)
      # Ojo: aquí ignoramos y=x-u y usamos x en F_total_hibrida
      return((1 - p_u) + p_u * F_pareto_max(x, alpha = params[1], y0 = params[2]))
    },

    "ln_tail" = F_exc_lognormal(y, mu = params[1], sigma = params[2]),

    "lognormal" = F_exc_lognormal(y, mu = params[1], sigma = params[2]),

    "gamma" = F_exc_gamma(y, shape = params[1], scale = params[2]),

    "weibull" = F_exc_weibull(y, shape = params[1], scale = params[2]),

    "fisk" = F_exc_fisk(y, shape = params[1], scale = params[2]),

    # KDE (cualquier kernel "KDE-xxx")
    {
      if (startsWith(model, "kde")) {
        xs <- tail$x
        fs <- tail$f
        F_exc_kde(y, xs, fs)
      } else {
        stop(paste("Modelo de cola no soportado en F_hybrid:", model))
      }
    }
  )

  # Combinación con el peso de la cola
  (1 - p_u) + p_u * F_exc
}

Q_hybrid <- function(p, body_sample, tail) {
  u   <- tail$u_opt[1]
  p_u <- tail$p_u[1]
  model <- tolower(tail$model_name[1])

  p <- pmin(pmax(p, 1e-12), 1 - 1e-12)

  # Parte del cuerpo empírico
  if (p <= (1 - p_u)) {
    # Cuantil reescalado dentro del cuerpo
    return(as.numeric(quantile(body_sample, probs = p / (1 - p_u), na.rm = TRUE)))
  }

  # Parte excedente
  p_exc <- (p - (1 - p_u)) / p_u
  params <- get_params_from_tail(tail)

  # Quantil de la cola según modelo
  q_exc <- switch(
    model,

    "gpd" = Q_exc_gpd(p_exc, sigma = params[1], xi = params[2]),

    "burr" = Q_exc_burr(p_exc, c = params[1], k = params[2], lambda = params[3]),

    "pareto" = Q_exc_pareto(p_exc, xm = params[1], alpha = params[2]),

    "pareto_max" = {
      # aquí trabajamos en escala X
      return(Q_pareto_max(p, alpha = params[1], y0 = params[2]))
    },

    "ln_tail" = Q_exc_lognormal(p_exc, mu = params[1], sigma = params[2]),

    "lognormal" = Q_exc_lognormal(p_exc, mu = params[1], sigma = params[2]),

    "gamma" = Q_exc_gamma(p_exc, shape = params[1], scale = params[2]),

    "weibull" = Q_exc_weibull(p_exc, shape = params[1], scale = params[2]),

    "fisk" = Q_exc_fisk(p_exc, shape = params[1], scale = params[2]),

    {
      if (startsWith(model, "kde")) {
        xs <- tail$x
        fs <- tail$f
        Q_exc_kde(p_exc, xs, fs)
      } else {
        stop(paste("Modelo de cola no soportado en Q_hybrid:", model))
      }
    }
  )

  # En casi todas las colas trabajamos en y=x-u, así que sumamos u
  u + q_exc
}







```


```{r}
tail <- readr::read_csv("../res/provincias/Alajuela_tail_Burr.csv")

# Suponiendo que esté en una sola fila:
body_sample <- df_subset$total[df_subset$total <= tail$u_opt[1]]

# Transformar X → U:
U <- sapply(df_subset$total, function(x) F_hybrid(x, body_sample, tail))

# Simulación inversa U → X:
X_sim <- sapply(U_sim_col, function(p) Q_hybrid(p, body_sample, tail))
```



```{r}
df <- read_csv("../data/clean/datos_limpios_log.csv")

provincias <- unique(df$provincia)
categorias <- unique(df$categoria)
sectores   <- unique(df$sector)

tabla <- todas_dependencias(
  df,
  provincias,
  categorias,
  sectores,
  carpeta_prov = "../res/provincias",
  carpeta_cat  = "../res/categorias",
  carpeta_sec  = "../res/sectores",
  n_sims = 200000
)

print(tabla)

```
