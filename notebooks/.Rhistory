ad_pvals[i] <- NA
}
}
stable_idx <- which(var_local <= 1.5 * min(var_local, na.rm = TRUE) & ad_pvals >= 0.05)
if(length(stable_idx) > 0){
u_opt <- u_seq[stable_idx[which.max(ad_pvals[stable_idx])]]
} else {
u_opt <- u_seq[which.min(var_local)]
}
plot(u_seq, mrl, type = 'b', pch = 19, col = 'firebrick',
main = paste('Mean Residual Life Plot', nombre), xlab = 'Umbral', ylab = 'MRL(u)')
abline(v = u_opt, col = "blue", lwd = 2, lty = 2)
grid()
legend("topright", legend = paste("Umbral √≥ptimo =", round(u_opt,3)),
col = "blue", lwd = 2, lty = 2, bty = "n")
return(u_opt)
}
set.seed(2025)
# Metropolis Hastings
mh_base <- function(log_post, inicio, propuesta_sd, n = 5000, limite_exp = 20){
k <- length(inicio)
cadena <- matrix(NA, nrow = n, ncol = k)
cadena[1, ] <- inicio
log_post_act <- log_post(inicio)
for (i in 2:n){
propuesta <- rnorm(k, mean = cadena[i-1,], sd = propuesta_sd)
propuesta <- pmin(pmax(propuesta, -limite_exp), limite_exp)
log_post_prop <- try(log_post(propuesta), silent = TRUE)
if(inherits(log_post_prop, "try-error") || is.na(log_post_prop) ||
is.nan(log_post_prop) || is.infinite(log_post_prop)){
cadena[i, ] <- cadena[i-1, ]
next
}
alpha <- exp(log_post_prop - log_post_act)
if(is.na(alpha) || is.nan(alpha) || is.infinite(alpha)) alpha <- 0
if(runif(1) < alpha){
cadena[i, ] <- propuesta
log_post_act <- log_post_prop
} else {
cadena[i, ] <- cadena[i-1, ]
}
}
colnames(cadena) <- paste0("param", 1:k)
return(cadena)
}
log_post_gamma <- function(par, x) {
shape <- exp(par[1])
rate <- exp(par[2])
log_lik <- sum(dgamma(x, shape = shape, rate = rate, log = TRUE))
log_prior <- dnorm(par[1], 0, 5, log = TRUE) + dnorm(par[2], 0, 5, log = TRUE)
return(log_lik + log_prior)
}
log_post_weibull <- function(par, x) {
shape <- exp(par[1])
scale <- exp(par[2])
log_lik <- sum(dweibull(x, shape = shape, scale = scale, log = TRUE))
log_prior <- dnorm(par[1], 0, 5, log = TRUE) + dnorm(par[2], 0, 5, log = TRUE)
return(log_lik + log_prior)
}
log_post_gpd <- function(par, x) {
xi <- par[1]
beta <- exp(par[2])
u <- min(x)  # offset a cero para dgpd
log_lik <- sum(dgpd(x - u, loc = 0, scale = beta, shape = xi, log = TRUE))
log_prior <- dnorm(par[1], 0, 0.5, log = TRUE) + dnorm(par[2], 0, 5, log = TRUE)
return(log_lik + log_prior)
}
mh <- function(log_post, inicio, x, n_iter=5000, sigma=0.1) {
k <- length(inicio)
cadena <- matrix(NA, nrow=n_iter, ncol=k)
cadena[1,] <- inicio
log_post_val <- log_post(inicio, x)
for(i in 2:n_iter) {
propuesta <- rnorm(k, mean=cadena[i-1,], sd=sigma)
log_post_prop <- log_post(propuesta, x)
alpha <- exp(log_post_prop - log_post_val)
if(!is.na(alpha) && runif(1) < alpha){
cadena[i,] <- propuesta
log_post_val <- log_post_prop
} else {
cadena[i,] <- cadena[i-1,]
}
}
colnames(cadena) <- paste0("param",1:k)
return(cadena)
}
ajustar_categoria <- function(datos, nombre) {
u_opt <- encontrar_umbral_optimo(datos, nombre)
cuerpo <- datos[datos <= u_opt]
cola   <- datos[datos > u_opt]
# Ajuste MH/Gibbs
gamma_chain   <- mh_block(log_post_gamma, c(0,0), cuerpo)
weibull_chain <- mh_block(log_post_weibull, c(0,0), cuerpo)
gpd_chain     <- mh_block(log_post_gpd, c(0,0), cola)
# Resumen de par√°metros
resumen <- function(chain) {
est <- apply(exp(chain), 2, mean)
ic_lower <- apply(exp(chain), 2, quantile, probs=0.025)
ic_upper <- apply(exp(chain), 2, quantile, probs=0.975)
data.frame(estimado=est, IC_2.5=ic_lower, IC_97.5=ic_upper)
}
tabla_gamma   <- resumen(gamma_chain)
tabla_weibull <- resumen(weibull_chain)
tabla_gpd     <- resumen(gpd_chain)
# Histogramas y densidades
hist_plot <- function() {
h <- ggplot(data.frame(x=datos), aes(x)) +
geom_histogram(aes(y=..density..), bins=40, fill='lightgray', color='black') +
geom_density(data=data.frame(x=cuerpo), aes(x), color='blue', size=1) +
geom_density(data=data.frame(x=cola), aes(x), color='red', size=1) +
geom_vline(xintercept=u_opt, linetype=2, color='black', size=1) +
labs(title=paste("Distribuci√≥n ajustada -", nombre), x="Valor", y="Densidad") +
annotate("text", x=max(datos)*0.7, y=max(density(datos)$y)*0.9,
label=paste("Gamma:", paste0(round(tabla_gamma$estimado,2), collapse=", "),
"\nWeibull:", paste0(round(tabla_weibull$estimado,2), collapse=", "),
"\nGPD:", paste0(round(tabla_gpd$estimado,2), collapse=", ")),
hjust=0)
return(h)
}
return(list(
u_opt=u_opt,
n_excesos=length(cola),
prop_excesos=length(cola)/length(datos),
tabla_gamma=tabla_gamma,
tabla_weibull=tabla_weibull,
tabla_gpd=tabla_gpd,
grafico=hist_plot()
))
}
resultados <- list()
for(cat in unique(df$categoria)){
datos_cat <- df$total[df$categoria==cat]
resultados[[cat]] <- ajustar_categoria(datos_cat, cat)
}
ajustar_categoria <- function(datos, nombre) {
u_opt <- encontrar_umbral_optimo(datos, nombre)
cuerpo <- datos[datos <= u_opt]
cola   <- datos[datos > u_opt]
# Ajuste MH/Gibbs
gamma_chain   <- mh(log_post_gamma, c(0,0), cuerpo)
weibull_chain <- mh(log_post_weibull, c(0,0), cuerpo)
gpd_chain     <- mh(log_post_gpd, c(0,0), cola)
# Resumen de par√°metros
resumen <- function(chain) {
est <- apply(exp(chain), 2, mean)
ic_lower <- apply(exp(chain), 2, quantile, probs=0.025)
ic_upper <- apply(exp(chain), 2, quantile, probs=0.975)
data.frame(estimado=est, IC_2.5=ic_lower, IC_97.5=ic_upper)
}
tabla_gamma   <- resumen(gamma_chain)
tabla_weibull <- resumen(weibull_chain)
tabla_gpd     <- resumen(gpd_chain)
# Histogramas y densidades
hist_plot <- function() {
h <- ggplot(data.frame(x=datos), aes(x)) +
geom_histogram(aes(y=..density..), bins=40, fill='lightgray', color='black') +
geom_density(data=data.frame(x=cuerpo), aes(x), color='blue', size=1) +
geom_density(data=data.frame(x=cola), aes(x), color='red', size=1) +
geom_vline(xintercept=u_opt, linetype=2, color='black', size=1) +
labs(title=paste("Distribuci√≥n ajustada -", nombre), x="Valor", y="Densidad") +
annotate("text", x=max(datos)*0.7, y=max(density(datos)$y)*0.9,
label=paste("Gamma:", paste0(round(tabla_gamma$estimado,2), collapse=", "),
"\nWeibull:", paste0(round(tabla_weibull$estimado,2), collapse=", "),
"\nGPD:", paste0(round(tabla_gpd$estimado,2), collapse=", ")),
hjust=0)
return(h)
}
return(list(
u_opt=u_opt,
n_excesos=length(cola),
prop_excesos=length(cola)/length(datos),
tabla_gamma=tabla_gamma,
tabla_weibull=tabla_weibull,
tabla_gpd=tabla_gpd,
grafico=hist_plot()
))
}
resultados <- list()
for(cat in unique(df$categoria)){
datos_cat <- df$total[df$categoria==cat]
resultados[[cat]] <- ajustar_categoria(datos_cat, cat)
}
resultados
resultados$INFRAESTRUCTURA
ajustar_categoria <- function(datos, nombre) {
u_opt <- encontrar_umbral_optimo(datos, nombre)
cuerpo <- datos[datos <= u_opt]
cola   <- datos[datos > u_opt]
# Ajuste MH/Gibbs
gamma_chain   <- mh(log_post_gamma, c(0,0), cuerpo)
weibull_chain <- mh(log_post_weibull, c(0,0), cuerpo)
gpd_chain     <- mh(log_post_gpd, c(0,0), cola)
# Resumen de par√°metros
resumen <- function(chain) {
est <- apply(exp(chain), 2, mean)
ic_lower <- apply(exp(chain), 2, quantile, probs=0.025)
ic_upper <- apply(exp(chain), 2, quantile, probs=0.975)
data.frame(estimado=est, IC_2.5=ic_lower, IC_97.5=ic_upper)
}
tabla_gamma   <- resumen(gamma_chain)
tabla_weibull <- resumen(weibull_chain)
tabla_gpd     <- resumen(gpd_chain)
# Histogramas y densidades
hist_plot <- function() {
h <- ggplot(data.frame(x=datos), aes(x)) +
geom_histogram(aes(y=..density..), bins=20, fill='lightgray', color='black') +
geom_density(data=data.frame(x=cuerpo), aes(x), color='blue', size=1) +
geom_density(data=data.frame(x=cola), aes(x), color='red', size=1) +
geom_vline(xintercept=u_opt, linetype=2, color='black', size=1) +
labs(title=paste("Distribuci√≥n ajustada -", nombre), x="Valor", y="Densidad") +
annotate("text", x=max(datos)*0.7, y=max(density(datos)$y)*0.9,
label=paste("Gamma:", paste0(round(tabla_gamma$estimado,2), collapse=", "),
"\nWeibull:", paste0(round(tabla_weibull$estimado,2), collapse=", "),
"\nGPD:", paste0(round(tabla_gpd$estimado,2), collapse=", ")),
hjust=0)
return(h)
}
return(list(
u_opt=u_opt,
n_excesos=length(cola),
prop_excesos=length(cola)/length(datos),
tabla_gamma=tabla_gamma,
tabla_weibull=tabla_weibull,
tabla_gpd=tabla_gpd,
grafico=hist_plot()
))
}
resultados <- list()
for(cat in unique(df$categoria)){
datos_cat <- df$total[df$categoria==cat]
resultados[[cat]] <- ajustar_categoria(datos_cat, cat)
}
resultados$INFRAESTRUCTURA
resultados$H√çDRICO
resultados$SOCIAL
ajustar_categoria <- function(datos, nombre) {
u_opt <- encontrar_umbral_optimo(datos, nombre)
cuerpo <- datos[datos <= u_opt]
cola   <- datos[datos > u_opt]
# Ajuste MH/Gibbs
gamma_chain   <- mh(log_post_gamma, c(0,0), cuerpo)
weibull_chain <- mh(log_post_weibull, c(0,0), cuerpo)
gpd_chain     <- mh(log_post_gpd, c(0,0), cola)
# Resumen de par√°metros
resumen <- function(chain) {
est <- apply(exp(chain), 2, mean)
ic_lower <- apply(exp(chain), 2, quantile, probs=0.025)
ic_upper <- apply(exp(chain), 2, quantile, probs=0.975)
data.frame(estimado=est, IC_2.5=ic_lower, IC_97.5=ic_upper)
}
tabla_gamma   <- resumen(gamma_chain)
tabla_weibull <- resumen(weibull_chain)
tabla_gpd     <- resumen(gpd_chain)
# Histogramas y densidades
hist_plot <- function() {
df_hist <- data.frame(x=datos)
h <- ggplot(df_hist, aes(x=x)) +
geom_histogram(aes(y=..density..), bins=25, fill='gray90', color='black') +
geom_histogram(data=data.frame(x=cuerpo), aes(y=..density..),
bins=25, fill='blue', alpha=0.3) +
geom_histogram(data=data.frame(x=cola), aes(y=..density..),
bins=25, fill='red', alpha=0.3) +
# L√≠nea vertical del umbral
geom_vline(xintercept=u_opt, linetype=2, color='black', size=1) +
# Texto del umbral y proporci√≥n de la cola
annotate("text", x=u_opt, y=max(density(datos)$y),
label=paste0("Umbral = ", round(u_opt,2),
"\nCola: ", length(cola), " obs (",
round(length(cola)/length(datos)*100,1), "%)"),
hjust=-0.1, color='black') +
# Par√°metros ajustados
annotate("text", x=min(datos), y=max(density(datos)$y)*0.9,
label=paste0(
"Gamma: ", paste0(round(tabla_gamma$estimado,2), collapse=", "), "\n",
"Weibull: ", paste0(round(tabla_weibull$estimado,2), collapse=", "), "\n",
"GPD: ", paste0(round(tabla_gpd$estimado,2), collapse=", ")
),
hjust=0, color='black', size=4) +
labs(title=paste("Distribuci√≥n ajustada (escala log) -", nombre),
x="Valor", y="Densidad (log)") +
scale_x_log10() +
theme_minimal() +
theme(plot.title = element_text(hjust = 0.5, face="bold", size=14))
return(h)
}
return(list(
u_opt=u_opt,
n_excesos=length(cola),
prop_excesos=length(cola)/length(datos),
tabla_gamma=tabla_gamma,
tabla_weibull=tabla_weibull,
tabla_gpd=tabla_gpd,
grafico=hist_plot()
))
}
resultados <- list()
for(cat in unique(df$categoria)){
datos_cat <- df$total[df$categoria==cat]
resultados[[cat]] <- ajustar_categoria(datos_cat, cat)
}
resultados$SOCIAL
resultados$INFRAESTRUCTURA
ajustar_categoria <- function(datos, nombre) {
u_opt <- encontrar_umbral_optimo(datos, nombre)
cuerpo <- datos[datos <= u_opt]
cola   <- datos[datos > u_opt]
# Ajuste MH/Gibbs
gamma_chain   <- mh(log_post_gamma, c(0,0), cuerpo)
weibull_chain <- mh(log_post_weibull, c(0,0), cuerpo)
gpd_chain     <- mh(log_post_gpd, c(0,0), cola)
# Resumen de par√°metros
resumen <- function(chain) {
est <- apply(exp(chain), 2, mean)
ic_lower <- apply(exp(chain), 2, quantile, probs=0.025)
ic_upper <- apply(exp(chain), 2, quantile, probs=0.975)
data.frame(estimado=est, IC_2.5=ic_lower, IC_97.5=ic_upper)
}
tabla_gamma   <- resumen(gamma_chain)
tabla_weibull <- resumen(weibull_chain)
tabla_gpd     <- resumen(gpd_chain)
# Histogramas y densidades
hist_plot <- function() {
df_hist <- data.frame(x=datos)
h <- ggplot(df_hist, aes(x = x)) +
# Histograma principal con transparencia
geom_histogram(aes(y = ..density..), bins = 30, fill = 'gray80',
color = 'gray50', alpha = 0.7) +
# Histograma del cuerpo (valores normales)
geom_histogram(data = data.frame(x = cuerpo), aes(y = ..density..),
bins = 25, fill = '#2E86AB', alpha = 0.6, color = NA) +
# Histograma de la cola (valores extremos)
geom_histogram(data = data.frame(x = cola), aes(y = ..density..),
bins = 25, fill = '#A23B72', alpha = 0.7, color = NA) +
# L√≠nea vertical del umbral m√°s destacada
geom_vline(xintercept = u_opt, linetype = "dashed",
color = '#F18F01', size = 1.2, alpha = 0.8) +
# Curvas de densidad para visualizar el ajuste
stat_function(fun = function(x) dgamma(x, shape = tabla_gamma$estimado[1],
rate = tabla_gamma$estimado[2]),
aes(color = "Gamma"), size = 1, alpha = 0.8) +
stat_function(fun = function(x) dweibull(x, shape = tabla_weibull$estimado[2],
scale = tabla_weibull$estimado[1]),
aes(color = "Weibull"), size = 1, alpha = 0.8) +
# Densidad emp√≠rica
geom_density(aes(color = "Densidad Emp√≠rica"), size = 1, alpha = 0.6) +
# Anotaci√≥n del umbral mejor posicionada
annotate("label", x = u_opt * 1.1, y = max(density(datos)$y) * 0.95,
label = paste0("üìä Umbral = ", round(u_opt, 2),
"\nüî¥ Cola: ", length(cola), " obs (",
round(length(cola)/length(datos)*100, 1), "%)",
"\nüîµ Cuerpo: ", length(cuerpo), " obs (",
round(length(cuerpo)/length(datos)*100, 1), "%)"),
hjust = 0, fill = "white", alpha = 0.9,
color = "black", size = 3.5, fontface = "bold") +
# Panel de par√°metros en esquina superior izquierda
annotate("label", x = min(datos) * 1.5, y = max(density(datos)$y) * 0.85,
label = paste0(
"üìà PAR√ÅMETROS AJUSTADOS\n",
"‚Ä¢ Gamma(Œ±=", round(tabla_gamma$estimado[1], 2),
", Œ≤=", round(tabla_gamma$estimado[2], 2), ")\n",
"‚Ä¢ Weibull(Œª=", round(tabla_weibull$estimado[1], 2),
", k=", round(tabla_weibull$estimado[2], 2), ")\n",
"‚Ä¢ GPD(Œæ=", round(tabla_gpd$estimado[1], 2),
", œÉ=", round(tabla_gpd$estimado[2], 2), ")"
),
hjust = 0, fill = "white", alpha = 0.9,
color = "black", size = 3.2) +
# Escala y etiquetas
scale_x_log10(
labels = scales::comma_format(accuracy = 1),
breaks = scales::trans_breaks("log10", function(x) 10^x)
) +
scale_color_manual(
name = "Distribuciones",
values = c("Gamma" = "#2E86AB",
"Weibull" = "#F18F01",
"Densidad Emp√≠rica" = "#A23B72")
) +
# T√≠tulos y temas
labs(
title = paste("üéØ AN√ÅLISIS CUERPO-COLAS -", nombre),
subtitle = "Distribuci√≥n de da√±os con ajuste de distribuciones (escala logar√≠tmica)",
x = "Valor de Da√±os (escala log‚ÇÅ‚ÇÄ)",
y = "Densidad",
caption = paste("Total de observaciones:", length(datos))
) +
theme_minimal() +
theme(
plot.title = element_text(hjust = 0.5, face = "bold", size = 16,
color = "#2C3E50"),
plot.subtitle = element_text(hjust = 0.5, size = 12, color = "#34495E"),
plot.caption = element_text(face = "italic", color = "#7F8C8D"),
axis.title = element_text(face = "bold", color = "#2C3E50"),
legend.position = "bottom",
legend.title = element_text(face = "bold"),
panel.grid.major = element_line(color = "gray90"),
panel.grid.minor = element_blank(),
plot.background = element_rect(fill = "white", color = NA)
) +
# Gu√≠a de colores para las √°reas
guides(
fill = guide_legend(override.aes = list(alpha = 0.7)),
color = guide_legend(override.aes = list(size = 2))
) +
# A√±adir etiquetas explicativas de las √°reas
annotate("text", x = median(cuerpo), y = max(density(datos)$y) * 0.3,
label = "CUERPO\n(eventos normales)",
color = "#2E86AB", fontface = "bold", size = 4) +
annotate("text", x = median(cola) * 1.5, y = max(density(datos)$y) * 0.2,
label = "COLA\n(eventos extremos)",
color = "#A23B72", fontface = "bold", size = 4)
print(h)
return(h)
}
return(list(
u_opt=u_opt,
n_excesos=length(cola),
prop_excesos=length(cola)/length(datos),
tabla_gamma=tabla_gamma,
tabla_weibull=tabla_weibull,
tabla_gpd=tabla_gpd,
grafico=hist_plot()
))
}
resultados <- list()
for(cat in unique(df$categoria)){
datos_cat <- df$total[df$categoria==cat]
resultados[[cat]] <- ajustar_categoria(datos_cat, cat)
}
resultados$INFRAESTRUCTURA
install.packages(c("R2jags", "coda", "bayesplot", "fitdistrplus"))
library(R2jags)
install.packages("R2jags")
library(R2jags))
library(R2jags)
install.packages("rjags")
library(rjags)
remotes::install_github("rpruim/CalvinBayes")
install.packages("remotes")
install.packages("remotes")
remotes::install_github("rpruim/CalvinBayes")
library(rjags)
library(R2jags)
library(evir)
install.packages("evir")
library(evir)
library(ggplot2)
set.seed(2025)
datos <- df$total[df$categoria == 'INFRAESTRUCTURA']
# 1Ô∏è‚É£ Umbral √≥ptimo
u_opt <- encontrar_umbral_optimo(datos, "MiCategoria")
# 2Ô∏è‚É£ Separar cuerpo y cola
cuerpo <- datos[datos <= u_opt]
cola   <- datos[datos > u_opt]
# 3Ô∏è‚É£ Funciones de MH para Gamma y Weibull
mh_base <- function(log_post, inicio, sd_prop, n = 5000){
k <- length(inicio)
cadena <- matrix(NA, nrow=n, ncol=k)
cadena[1,] <- inicio
log_post_val <- log_post(inicio)
for(i in 2:n){
propuesta <- rnorm(k, mean=cadena[i-1,], sd=sd_prop)
log_post_prop <- log_post(propuesta)
alpha <- exp(log_post_prop - log_post_val)
if(!is.na(alpha) && runif(1) < alpha){
cadena[i,] <- propuesta
log_post_val <- log_post_prop
} else {
cadena[i,] <- cadena[i-1,]
}
}
colnames(cadena) <- paste0("param", 1:k)
return(cadena)
}
# Log-posterior Gamma
log_post_gamma <- function(par, x){
shape <- exp(par[1])
rate  <- exp(par[2])
log_lik <- sum(dgamma(x, shape=shape, rate=rate, log=TRUE))
log_prior <- dnorm(par[1], 0, 5, log=TRUE) + dnorm(par[2], 0, 5, log=TRUE)
return(log_lik + log_prior)
}
# Log-posterior Weibull
log_post_weibull <- function(par, x){
shape <- exp(par[1])
scale <- exp(par[2])
log_lik <- sum(dweibull(x, shape=shape, scale=scale, log=TRUE))
log_prior <- dnorm(par[1],0,5,log=TRUE) + dnorm(par[2],0,5,log=TRUE)
return(log_lik + log_prior)
}
# 4Ô∏è‚É£ Ajustar cuerpo
mh_gamma <- mh_base(function(p) log_post_gamma(p, cuerpo), inicio=c(0,0), sd_prop=c(0.1,0.1), n=10000)
mh_weibull <- mh_base(function(p) log_post_weibull(p, cuerpo), inicio=c(0,0), sd_prop=c(0.1,0.1), n=10000)
# Convertir a escala real
gamma_params <- exp(colMeans(mh_gamma))
weibull_params <- exp(colMeans(mh_weibull))
# 5Ô∏è‚É£ Ajustar cola con GPD
gpd_fit <- gpd(cola, threshold=0)
gpd_params <- c(xi=gpd_fit$par.ests[1], beta=gpd_fit$par.ests[2])
# 6Ô∏è‚É£ Bootstrap IC para cuerpo y cola
bootstrap_ic <- function(x, log_post, nboot=500){
params <- replicate(nboot, {
samp <- sample(x, replace=TRUE)
cadena <- mh_base(function(p) log_post(p, samp), inicio=c(0,0), sd_prop=c(0.1,0.1), n=5000)
exp(colMeans(cadena))
})
t(apply(params,1,quantile,c(0.025,0.975)))
}
gamma_ic <- bootstrap_ic(cuerpo, log_post_gamma)
library(R2jags)
library(rjags)
library(rjags)
